%% $RCSfile: proj_report_outline.tex,v $
%% $Revision: 1.3 $
%% $Date: 2016/06/10 03:41:54 $
%% $Author: kevin $

\documentclass[11pt
              , a4paper
              , twoside
              , openright
              ]{report}


\usepackage{float} % lets you have non-floating floats
\usepackage{url} % for typesetting urls
\usepackage{enumitem} % for nicer list
\usepackage{pifont} % for checkbox

%
%  We don't want figures to float so we define
%
\newfloat{fig}{thp}{lof}[chapter]
\floatname{fig}{Figure}

%% These are standard LaTeX definitions for the document
%%
\title{%
Tutorial Builder \\
\large Preliminary Report}

\author{Zoltan Debre}

% Victoria University ECS
\usepackage[image,ecs,mcompsci]{vuwproject}

\supervisor{Dr Stuart Marshall}

% Comment this out if you want the date printed.
% \date{}

\begin{document}

% Make the page numbering roman, until after the contents, etc.
\frontmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}

Presenting a computer programming problem or solution with a high-quality video is time consuming and it is not easy to update.

Technical content producers are struggle to find an efficient and interactive way to show their work.

This research introduces a tool that can be used for creating an interactive tutorial.

This tool shows programming code snippets in web based code editor so the content creator can build a playable step by step "movie" with it.

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

This project is about building an online publishing tool prototype, using code editors and step by step instructions to present programming challenges or solutions for a computer science problem.

The prototype has two parts, an administration area, where the content creator can build a tutorial, and a player tool, where the recorded steps would be presented. This player should be embeddable in any blog post or website.

The primary target user is the creator, who composes a new tutorial. The creator can be a teacher, or an open source project owner, who would like to introduce his tool or code.

The secondary user is the consumer, who wants to learn or know more about a problem or a coding solution.

\section{Motivation}

We all have the unstoppable desire to learn. We are keen to know more about the world around us, about our hobby and our profession. In software development, in computer science, the knowledge is essential, it is the key to succeeding. Reading, studying, sharing. An infinite loop of collecting and adapting new practices.

In information technology, especially in programming languages, writing blog posts, creating static, step by step tutorials are a popular way to share or learn something new. Producing and sharing the content is easier nowadays, but still required more effort from the creator, when they want to deliver an easy to understand high-quality tutorials.

Creating interactive tutorials are appealing, but the production cost is much higher. Recording a video tutorial or especially updating it is time-consuming and involves more effort from the creator.

I think an ideal solution would be a healthy mix of static and dynamic contents. Where the learner can read instructions but meanwhile can watch the steps in a code editor, in a more realistic environment.

\chapter{The problem and the solution}

\section{The problem}

When a developer, teacher or hobbyist would like to present a computer programming problem or solution, most of the times they record a video and publish it on YouTube. Sometimes the easiest way to record a video of a conference/meetup presentation or a live coding session. However recording and editing a high-quality video is time-consuming and less flexible. It is hard to update.

Other problem with showing tutorials with a simple video, that the audience cannot try it out, they have to configure their computer and environment to play with the presented solution.

Most of the cases we would like to show instructions and code snippets, mainly text-based contents. It is preferred to show code snippets in a more realistic environment, in a code editor. So using the online code editor, with a pre-scripted way to play our presentation, where the user can step back and forward and can modify or play with the code is more interactive, involving and helps to understand a problem more clearly.

Additionally, it is much easier to maintain, upgrade or fix for the content creator.

Furthermore, the user can try out and can see the result also, so immediately can practice the new information.

\section{Personas and their goals}

\subsection{Primary persona}

Content creator, open source project maintainer, teacher.

Their motivation is to present a technical problem and the solution clearly and in an easy-to-understand way. The best option showing a demo, what happens if we insert the suggested code, how easy to use it. Most of the times a presentation involves more steps. For example we would like to show a starting state, maybe a few lines of code which we are able to simplify, so in this case the first step is showing the problem and after we show step by step how we solve that.

\subsection{Secondary persona}

The consumer, who watch the presentation, who reads the tutorial and who wants to learn more about the actual problem.

They would like to play, stop, control the presentation. Control the flow, going forward or stepping back.

They would like to try out the solution, for example how the final state changes if they modify the code.

\section{The Solution}

I develop a prototype web app, where the content producer can create a simple step by step tutorial, and the content consumer can "watch" this tutorial and can interact with it.

There are two different users:
\begin{itemize}[noitemsep]
\item content producer, for example a teacher
\item content consumer, for instance a student
\end{itemize}

\section{Requirements}

Requirements are separated in three different groups.\\

\noindent Requirements from the teacher perspective:
\begin{itemize}[noitemsep]
\item Teacher can navigate to Admin page.
\item Teacher can create a new tutorial.
\item Teacher can add steps to the tutorial.
\item A step could be four different type:
\begin{itemize}[noitemsep]
\item Instruction type is a text content.
\item Html type, which adding content to the html editor box.
\item Css type, which adding content to the css editor box.
\item JavaScript type, which adding content to the javascript editor box.
\item Teacher can modify the sort of the steps with reorganizing with drag and drop.
\end{itemize}
\end{itemize}

\noindent Requirements from the student perspective:
\begin{itemize}[noitemsep]
\item Student can see a list of tutorials.
\item Student can click on a tutorial and can see the steps.
\item Steps are played in sort.
\item Student can "play" and "watch" the steps.
\item Student can "pause" and step "backward".
\end{itemize}

\noindent User interface requirements:
\begin{itemize}[noitemsep]
\item The tutorial screen has five area:
\item Instruction area
\item Html code editor textarea.
\item Css code editor textarea.
\item Javascript code editor textarea.
\item Html preview textarea.
\end{itemize}

\noindent The main website has two main section:
\begin{itemize}
\item Admin page where Teacher can edit tutorials.
\item Tutorials page where Students can select and watch tutorials.
\end{itemize}

\chapter{Background and Related Work}

During the development and research work, I found a few related interesting projects. These are similar or partly I can use them.

\section{CodeMirror Movie}

This project is interesting, because I found it, when I checked the most popular web-based code editor tool, CodeMirror website. The creator of the CodeMirror wanted to present his tool with a realistic way, so he created CodeMirror Movie. \cite{cm-movie}

This solution highly coupled with CodeMirror, it is like an add-on, so it is possible to attach any CodeMirror implementation. (More about CodeMirror in the next section.)

Adding CodeMirror Movie to our project is quite straightforward. The open source repository provides a CSS and a JS file, which has to add into our page.

This tool is mainly target web-developers, who can add code and scripts to their websites.

Editing "the movie" script is manual. There is a simple syntax which control the presentation steps and this script should be added to the textarea which will be in the code editor.

We clearly see, that it is a very effective way to build a presentation, however it requires real development skills.\\

\noindent Pros:
\begin{itemize}[noitemsep]
\item simple, lightweight implementation
\item easy to add your project if you use CodeMirror and you are a developer
\item simple script language to manage the presentation
\item user can use the code editor to try out the presented solution
\end{itemize}
Cons:
\begin{itemize}[noitemsep]
\item mainly for developers only
\item highly coupled with CodeMirror
\end{itemize}


\section{Comparison of online code editors}

There are 3 popular web based code editors: CodeMirror, Ace Editor and Monaco.

CodeMirror and Ace Editor are commonly used on websites and different projects. Monaco is a new solution from Microsoft and it is extracted from their popular Microsoft Visual Studio Code developer tool.

There is not significant differences between them. All has the most important code editor features, like supporting more than 100 languages, autocompletion, syntax highlighting, controlling with shortcuts.

I choose CodeMirror, because it has already Ember.js support. Thanks for the ivy-codemirror Ember addon, it can be added to any Ember.js project with the installation of the addon. \\

\noindent CodeMirror
\begin{itemize}[noitemsep]
\item Github link: \url{https://github.com/codemirror/CodeMirror}
\item Website: \url{http://codemirror.net/}
\item Popularity (GitHub Star): 9396
\item Ember.js Addon: \url{https://www.emberobserver.com/addons/ivy-codemirror} \\
\end{itemize}

\noindent Ace Editor
\begin{itemize}[noitemsep]
\item Github link: \url{https://github.com/ajaxorg/ace}
\item Website: \url{https://ace.c9.io}
\item Popularity (GitHub Star): 12950
\item Ember.js Addon: none
\end{itemize}

\noindent Monaco
\begin{itemize}[noitemsep]
\item Github link: \url{https://github.com/Microsoft/monaco-editor}
\item Website: \url{https://microsoft.github.io/monaco-editor/}
\item Popularity (GitHub Star): 2322
\item Ember.js Addon: none
\end{itemize}

\section{Reviewing of code sharing websites}

We can use code editor and sharing platforms also when we want to demo a small feature or describe a problem. These websites are a combination of code editors and an iframe where we can see the preview of the code snippets.

Common feature to split the screen and providing different windows for editing html, css and javascript separately.

User can save the edited content also. Most of them can be embed in a blog post or in other website. \\

\noindent Most important findings:
\begin{itemize}[noitemsep]
\item All use Code Mirror as code editor
\item All of them separate the css, html and javascript editing in different screens, but they merge to one file and preview this merged html file in an iframe.
\item Saving the different type of code (css, javascript, html) separately.
\end{itemize}

\newpage

\begin{tabular}{|l|l|l|l|l|}
\hline
& Code Pen & JSBin & JSFiddle & Ember Twiddle \\
\hline
Link to open source project & not open source & [a] & not open source & [b]  \\
\hline
Website & [c] & [d] & [e] & [f] \\
\hline
Code Editor & Code Mirror & Code Mirror & Code Mirror & Code Mirror \\
\hline
Support embedding & yes & yes & yes & yes \\
\hline
\end{tabular}\\

Links:
\begin{itemize}[noitemsep]
\item a: \url{https://github.com/jsbin/jsbin} \\
\item b: \url{https://github.com/ember-cli/ember-twiddle} \\
\item c: \url{http://codepen.io} \\
\item d: \url{http://jsbin.com} \\
\item e: \url{https://jsfiddle.net/} \\
\item f: \url{https://ember-twiddle.com/} \\
\end{itemize}

\chapter{Completed Work}

\section{The technology of choice}

One of the most popular programming languages in web development is JavaScript. The usage of this frontend focused technology is growing quickly.  It is the 7th on Tiobe Index, which is a good indicator of programming languages popularity. \cite{tiobe}

Learning and teaching JavaScript, HTML and CSS is important. My tool focuses on this three main building blocks of the web.

Building a frontend heavy application, with a dynamic, user-friendly interface is more common nowadays. In the last few years JavaScript based frontend frameworks became a matured, production ready tools. Server side technologies, like database management and time and resource heavy processes are separated from the user focused, design driven view layer, which is developed with usage of frontend frameworks.

The most popular tools are Angular.js, React.js and Ember.js. In my project I use Ember.js. It is an "opinionated" framework. Opinionet, convention over configuration driven framework means, that developers should follow specific conventions, instead of freely using the tool. A more strict environment helps to adapt the best practices and speed up the development process also.

Certainly, we still have to store data and information, so we cannot live without backend and server technology. Luckily there are already cloud-based tools for managing databases. I use Firebase, which is a service provided by Google. Firebase is a cloud-based database, document-store solution and easy to integrate with Ember.js.

Additionally, I build a traditional backend server application also to support development and experimenting with a real server side and a cloud-based solutions parallel. My preferred technology on backend side is Ruby on Rails, a popular, also opinionated and convention over configuration driven backend framework.


\section{The development environment}

Following the most modern standard of web applications, I separate the user faced frontend development and the data store, backend development.

The user face frontend application uses Ember.js frontend framework. The primer data store is Firebase cloud based database, however I already created a Ruby on Rails application which is running when the application is in development mode.

Ember.js development requires Node.js on the development machine to run the development environment. This development environment helps to run and modify frontend code quickly and it generates the final, deployable production code also. The production version of the application is only a static website. It means, there is one index.html, two JavaScript files and two CSS files.

\section{Frontend features}

The look and feel of the application will follow the standard Bootstrap style. Bootstrap is added to the project. I uses SaSS version of the Bootstrap, so I can customize it with the modification of the SaSS variables. SaSS is a modern CSS development environment, helps to programmatically modify the CSS.

The home page of the application is only a placeholder. I added a navigation bar with the following links: Home, Sandbox, Tutorials, Admin.

I implemented a breadcrumb bar also, which helps in navigation.

I created first a Sandbox area, where I experiment with the CodeMirror code editor and an IFrame, which shows the preview. This Sandbox page contains the editor. When the source code is updated, the preview page automatically shows the generated website. This features uses Ember.js default two-way bindings capability.

Database management is already implemented. The main adapter is the Firebase adapter, which automatically update data to the Firebase server. Firebase is a real time database. The limited, free to use version is enough for experimenting and for demo.

The secondary adapter is a JSONApi Adapter. JSON Api \cite{jsonapi} is a new standard of data communication format. This is the Ember.js default adapter.

\section{Implemented requirements}

Previously listed requirements, the followings are already implemented. \\

\noindent Requirements from the teacher perspective:
\begin{itemize}[noitemsep]
\item \ding{51} Teacher can navigate to Admin page.
\item \ding{51} Teacher can create a new tutorial.
\item \ding{51} Teacher can add steps to the tutorial.
\end{itemize}

\noindent Requirements from the student perspective:
\begin{itemize}[noitemsep]
\item \ding{51} Student can see a list of tutorials.
\end{itemize}

\noindent User interface requirements:
\begin{itemize}[noitemsep]
\item \ding{51} Html code editor textarea.
\item \ding{51} Html preview textarea.
\end{itemize}

\noindent The main website has two main section:
\begin{itemize}
\item \ding{51} Admin page where Teacher can edit tutorials.
\item \ding{51} Tutorials page where Students can select and watch tutorials.
\end{itemize}

\section{Future work}

In the following four months I will focus for the implementation of the rest of the features. Additionally, it is important to evaluate the prototype, so I would like to use the tutorial builder on a public website and collecting feedback from the users. \\

\noindent Requirements from the teacher perspective:
\begin{itemize}[noitemsep]
\item A step could be four different type:
\begin{itemize}[noitemsep]
\item Instruction type is a text content.
\item Html type, which adding content to the html editor box.
\item Css type, which adding content to the css editor box.
\item JavaScript type, which adding content to the javascript editor box.
\item Teacher can modify the sort of the steps with reorganizing with drag and drop.
\end{itemize}
\end{itemize}

\noindent Requirements from the student perspective:
\begin{itemize}[noitemsep]
\item Student can click on a tutorial and can see the steps.
\item Steps are played in sort.
\item Student can "play" and "watch" the steps.
\item Student can "pause" and step "backward".
\end{itemize}

\noindent User interface requirements:
\begin{itemize}[noitemsep]
\item The tutorial screen has five area:
\item Instruction area
\item Css code editor textarea.
\item Javascript code editor textarea.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\backmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{acm}

\begin{thebibliography}{9}

\bibitem{tiobe}
Tiobe.com
\url{http://www.tiobe.com/tiobe_index}

\bibitem{cm-movie}
CodeMirror Movie
\url{https://github.com/sergeche/codemirror-movie}

\bibitem{jsonapi}
\url{http://jsonapi.org}

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
